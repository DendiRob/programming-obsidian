#### JWT состоит из трех частей: заголовок `header`, полезные данные `payload` и подпись `signature`


## Header
Хедер _JWT_ содержит информацию о том, как должна вычисляться _JWT_ подпись. Хедер — это тоже _JSON_ объект, который выглядит следующим образом:
```JS
header = { "alg": "HS256", "typ": "JWT"}
```
Поле `typ` не говорит нам ничего нового, только то, что это _JSON Web Token_. Интереснее здесь будет поле `alg`, которое определяет алгоритм хеширования. Он будет использоваться при создании подписи. `HS256` — не что иное, как `HMAC-SHA256`, для его вычисления нужен лишь один секретный ключ (более подробно об этом в шаге 3). Еще может использоваться другой алгоритм `RS256` — в отличие от предыдущего, он является ассиметричным и создает два ключа: публичный и приватный. С помощью приватного ключа создается подпись, а с помощью публичного только лишь проверяется подлинность подписи, поэтому нам не нужно беспокоиться о его безопасности.

## Payload
**Payload** — это полезные данные, которые хранятся внутри _JWT_. Эти данные также называют _JWT-claims_ (заявки). В примере, который рассматриваем мы, сервер аутентификации создает _JWT_ с информацией об _id_ пользователя — **userId**.
```JS
payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
```
Мы положили только одну _заявку_ (claim) в _payload_. Вы можете положить столько _заявок_, сколько захотите. Существует список стандартных _заявок_ для _JWT_ payload — вот некоторые из них:
- _iss_ (issuer) — определяет приложение, из которого отправляется токен.
- _sub_ (subject) — определяет тему токена.
- _exp_ (expiration time) — время жизни токена.

Эти поля могут быть полезными при создании _JWT_, но они не являются обязательными. Если хотите знать весь список доступных полей для _JWT_, можете заглянуть в [Wiki](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields). Но стоит помнить, что чем больше передается информации, тем больший получится в итоге сам _JWT_. Обычно с этим не бывает проблем, но все-таки это может негативно сказаться на производительности и вызвать задержки во взаимодействии с сервером.

## SIGNATURE
Подпись вычисляется с использование следующего псевдо-кода: 
```JS
const SECRET_KEY = 'cAtwa1kkEy';
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload);
const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
```
Алгоритм **base64url** кодирует хедер и payload, созданные на _1_ и _2_ шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.
```JS
// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 
// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ 
// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

## Теперь объединим все три JWT компонента вместе
Теперь, когда у нас есть все три составляющих, мы можем создать наш _JWT_. Это довольно просто, мы соединяем все полученные элементы в строку через точку.
```JS
const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature) 
// JWT Token 
//eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```