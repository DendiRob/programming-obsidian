1. Реактивность - если кратко, то это способность интерфейсу приложения отрисовывать актуальное состояние приложения
2. Есть следующие основные отличия:
	-  Теперь код можно логически структурировать, раньше всё нужно было подразделять на соответствующие методы, что усложняло процесс разработки
	-  главным преимуществом Composition API является возможность писать composable-функции, т.е. функции, возвращающие целый функционал, который можно переиспользовать в различных частях приложения. Допустим, нам нужно реализовать отслеживание координат мыши внутри компонента:
	![[../Pasted image 20240422141015.png]]
	- новые методы задания реактивности ref, swallowRef, reactive
3.  Мы используем реактивность в след случае:
	- reactive - когда работаем только с объектами (с примитивами нельзя, также нельзя его деструктурировать)
	- ref - используем в примитивами и объектами
	- shallowRef - Функция shallowRef похожа на ref, но с одним ключевым отличием: изменения, внесенные в ее свойства, вызовут изменение только в том случае, если вы измените ссылку на память. Она используется для оптимизации производительности больших структур данных или интеграции с внешними системами управления состоянием. Просматривая официальные документы, сообщество Vue предоставляет нам следующий пример.
	```JS
	const state = shallowRef({ count: 1 })
	
	// does NOT trigger change
	state.value.count = 2
	
	// does trigger change
	state.value = { count: 2 }
	```
	4. defineExpose - позволяет использовать внутренние данные ребенка,в том числе, чтобы внутри вызывать его(ребенка) функции
	5.  provide / Inject используется,чтобы передавать пропсы (избегаем пропс дриллинг), не используется,так как пропсы нереактивные
	6. Реактивность во vue3 построенна на прокси объекте в который обернут нужный объект, и через него уже дергаются геттеры и сеттеры. Теперь есть глубокая реактивность,которая пзволяет любому и точечному изменению в объекте быть отображенным
	7. 