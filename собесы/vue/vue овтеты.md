1. Реактивность - если кратко, то это способность интерфейсу приложения отрисовывать актуальное состояние приложения
2. Есть следующие основные отличия:
	-  Теперь код можно логически структурировать, раньше всё нужно было подразделять на соответствующие методы, что усложняло процесс разработки
	-  главным преимуществом Composition API является возможность писать composable-функции, т.е. функции, возвращающие целый функционал, который можно переиспользовать в различных частях приложения. Допустим, нам нужно реализовать отслеживание координат мыши внутри компонента:
	
	![[../../imgs/Pasted image 20240422141015.png]]
	
	- новые методы задания реактивности ref, swallowRef, reactive
3.  Мы используем реактивность в след случае:
	- reactive - когда работаем только с объектами (с примитивами нельзя, также нельзя его деструктурировать)
	- ref - используем в примитивами и объектами
	- shallowRef - Функция shallowRef похожа на ref, но с одним ключевым отличием: изменения, внесенные в ее свойства, вызовут изменение только в том случае, если вы измените ссылку на память. Она используется для оптимизации производительности больших структур данных или интеграции с внешними системами управления состоянием. Просматривая официальные документы, сообщество Vue предоставляет нам следующий пример.
	```JS
	const state = shallowRef({ count: 1 })
	
	// does NOT trigger change
	state.value.count = 2
	
	// does trigger change
	state.value = { count: 2 }
	```
	4. defineExpose - позволяет использовать внутренние данные ребенка, в том числе, чтобы внутри вызывать его(ребенка) функции
	5.  provide / Inject используется, чтобы передавать пропсы (избегаем пропс дриллинг), не используется, так как пропсы нереактивные
	6. Реактивность во vue3 построена на прокси объекте в который обернут нужный объект, и через него уже дергаются геттеры и сеттеры. Теперь есть глубокая реактивность, которая позволяет любому и точечному изменению в объекте быть отображенным
	7. [[жизненный цикл компонента]]
	8. [[слоты]]
	9.  `<KeepAlive>` is a built-in component that allows us to conditionally cache component instances when dynamically switching between multiple components.
	10. `<Teleport>` is a built-in component that allows us to "teleport" a part of a component's template into a DOM node that exists outside the DOM hierarchy of that component.