```JS
<script> 
export default { 
data() { 
	return { 
		count: 0, //реактивные переменные
	} 
	}, 
methods: { 
	addToCount(n) {
	 this.count += n this.$emit('add-to-count', n) 
	 }, 
},
props: {
	anyProps: {
		type: anytype...
	}
},

</script>
```

### data()
Функция, которая возвращает объект данных для экземпляра компонента. Не следует использовать в `data` для отслеживания объекты со своим собственным поведением, например объекты API браузера или свойства прототипа. Лучше когда данные компонента представляет простой объект.

После инициализации системы реактивности больше не будет возможности добавлять реактивные свойства к корневому объекту data. Поэтому рекомендуется объявить все необходимые свойства корневого уровня перед созданием экземпляра.

После создания экземпляра доступ к оригинальном объекту с данными можно получить через `vm.$data`. Экземпляр компонента также проксирует все свойства, найденные в объекте данных, поэтому обращение к `vm.a` будет эквивалентно `vm.$data.a`.

Свойства, чьи имена начинаются с символа `_` или `$`, **не будут проксироваться** экземпляром компонента, так как могут конфликтовать с внутренними свойствами Vue и методами API. Доступ к ним можно получить следующим образом `vm.$data._property`.

### props :
Список/хэш атрибутов, которые могут принимать данные от родительского компонента. Может использоваться простой синтаксис массивом или альтернативный синтаксис объектом, который позволяет указывать расширенные настройки: устанавливать проверку типа, пользовательскую валидацию или значение по умолчанию.

При использовании объектного синтаксиса можно использовать следующие опции:

- `type`: может быть одним из нативных конструкторов: `String`, `Number`, `Boolean`, `Array`, `Object`, `Date`, `Function`, `Symbol` или любой функцией пользовательского конструктора или массивом из вышеперечисленных вариантов. Проверяет имеет ли входной параметр заданный тип и выдаёт предупреждение если нет. Подробнее в разделе [указания типа входных параметров](https://vueframework.com/docs/v3/ru/ru/guide/component-props.html#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2).
    
- `default`: `any` Определяет значение по умолчанию для входного параметра. Если входной параметр не был передан, то будет использовано это значение. При указании в качестве значения по умолчанию объекта или массива необходимо возвращать их из функции фабрики.
    
- `required`: `Boolean` Определяет является ли входной параметр обязательным. В не-production окружении будет выводиться предупреждение в консоли, если значение истинно, но входной параметр не передавался.
    
- `validator`: `Function` Пользовательская функция валидации, которая получает значение входного параметра единственным аргументом. В не-production окружении будет выводиться предупреждение в консоли, если вернётся значение приводимое к false (т.е., если валидация не пройдена). Подробнее в разделе [валидации входных параметров](https://vueframework.com/docs/v3/ru/ru/guide/component-props.html#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2).
```JS
//просто синтаксис
app.component('props-demo-simple', {
  props: ['size', 'myMessage']//пропсы,которые приходят
})
```

```JS
// объектный синтаксис с валидацией
app.component('props-demo-advanced', {
  props: {
    // проверка типа
    height: Number,
    // проверка типа + другие валидации
    age: {
      type: Number,
      default: 0,
      required: true,
      validator: value => {
        return value >= 0
      }
    }
  }
})
```
### computed:
https://salamba.ru/kak-rabotaet-computed-vo-vue-3/#h-chto-takoe-computed (перечитать)
Концепция `computed` в стиле Options API в Vue предоставляет функциональность для вычисления новых значений на основе реактивных данных и предоставляет их в виде вычисляемых свойств.

Кроме того, `computed` также может иметь дополнительные свойства, такие как `get` и `set`, которые позволяют управлять поведением свойства в зависимости от того, является ли оно только для чтения или может быть изменено. Они также предоставляются для того, чтобы вы могли создавать вычисляемые значения на основе других вычисляемых значений.

Обратите внимание, что при использовании стрелочной функции для вычисляемого свойства `this` не будет указывать на экземпляр компонента. Доступ к нему в таких случаях можно получить через первый аргумент функции:

```JS
computed: {
  aDouble: vm => vm.a * 2
}
```

Вычисляемые свойства кэшируются и пересчитываются только при изменении своих реактивных зависимостей. Обратите внимание, если какая-либо зависимость находится за пределами области видимости экземпляра (т.е. не является реактивной), то в таком случае вычисляемое свойство **обновляться не будет**.

```JS
const app = createApp({
  data() {
    return { a: 1 }
  },
  computed: {
    // только получение
    aDouble() {
      return this.a * 2
    },
    // получение и установка
    aPlus: {
      get() {
        return this.a + 1
      },
      set(v) {
        this.a = v - 1
      }
    }
  }
})

const vm = app.mount('#app')

console.log(vm.aPlus) // => 2
vm.aPlus = 3
console.log(vm.a) // => 2
console.log(vm.aDouble) // => 4
```
## Зачем **get** и **set** в **computed** свойстве?

В  вычисляемые свойства (computed) могут иметь как геттер, так и сеттер. Геттер используется для получения значения свойства, а сеттер - для установки значения.

Использование геттера и сеттера в `computed` свойстве дает возможность дополнительной обработки данных перед их возвратом или установкой. Например, мы можем использовать сеттер, чтобы выполнить какой-то код при изменении значения свойства.
### methods:

- Методы, которые будут добавлены в экземпляр компонента. К ним можно получить доступ через экземпляр или использовать их в выражениях директив. Все методы имеют свой контекст `this`, который автоматически привязывается к экземпляру компонента.
    
    Примечание
    **Не используйте стрелочные функции при определении методов** (например, `plus: () => this.a++`). Стрелочные функции связываются с родительским контекстом, поэтому `this` не будет указывать на экземпляр компонента и `this.a` окажется неопределённым.

Пример:
```JS
    const app = createApp({
      data() {
        return { a: 1 }
      },
      methods: {
        plus() {
          this.a++
        }
      }
    })
    
    const vm = app.mount('#app')
    
    vm.plus()
    console.log(vm.a) // => 2
    ```
### watch: 
- Объект, ключ в котором определяет выражения для отслеживания изменений, а значение соответствующий коллбэк для вызова. Значение также может быть строкой с именем метода или объектом, содержащим дополнительные опции. Экземпляр компонента будет вызывать `$watch()` для каждой записи в объекте при инициализации. Подробнее о дополнительных опциях `deep`, `immediate` и `flush` в разделе [$watch](https://vueframework.com/docs/v3/ru/ru/api/instance-methods.html#watch).
Как я понял, это просто коллбеэк для любого изменения какой-либо переменной
    
- **Пример:**
    
```JS
    const app = createApp({
      data() {
        return {
          a: 1,
          b: 2,
          c: {
            d: 4
          },
          e: 5,
          f: 6
        }
      },
      watch: {
        // отслеживание свойства верхнего уровня
        a(val, oldVal) {
          console.log(`новое значение: ${val}, старое: ${oldVal}`)
        },
        // строка с именем метода
        b: 'someMethod',
        // коллбэк будет вызываться каждый раз, когда изменится любое из свойств
        // наблюдаемого объекта, независимо от глубины вложенности
        c: {
          handler(val, oldVal) {
            console.log('изменилось свойство c')
          },
          deep: true
        },
        // отслеживание одного вложенного свойства объекта
        'c.d': function (val, oldVal) {
          // do something
        },
        // коллбэк будет вызван сразу после начала наблюдения
        e: {
          handler(val, oldVal) {
            console.log('изменилось свойство e')
          },
          immediate: true
        },
        // передача массива коллбэков; они будут вызываться один за другим
        f: [
          'handle1',
          function handle2(val, oldVal) {
            console.log('вызван handle2')
          },
          {
            handler: function handle3(val, oldVal) {
              console.log('вызван handle3')
            }
            /* ... */
          }
        ]
      },
      methods: {
        someMethod() {
          console.log('изменилось свойство b')
        },
        handle1() {
          console.log('вызван handle1')
        }
      }
    })
    
    const vm = app.mount('#app')
    
    vm.a = 3 // => новое значение: 3, старое: 1
```

Примечание
    Не используйте стрелочные функции при объявлении методов-наблюдателей** (например, `searchQuery: newValue => this.updateAutocomplete(newValue)`). Стрелочные функции связываются с родительским контекстом, поэтому `this` не будет указывать на экземпляр компонента и `this.updateAutocomplete` окажется неопределённым.
### emits:
- Список/хэш пользовательских событий, которые могут генерироваться компонентом. Может использоваться простой синтаксис массивом или альтернативный синтаксис объектом, который позволяет определить валидацию для событий.
    
    При использовании объектного синтаксиса значением каждого свойства может быть `null` или функция валидации. Функция будет получать дополнительные аргументы, переданные при вызове `$emit`. Например, для `this.$emit('foo', 1)` соответствующая функция валидации для `foo` получит аргументом значение `1`. Функция должна возвращать булево, чтобы указать корректность передаваемых с событием аргументов.
    
Использование:

```JS
    const app = createApp({})
    
    // Синтаксис массивом
    app.component('todo-item', {
      emits: ['check'],
      created() {
        this.$emit('check')
      }
    })
    
    // Объектный синтаксис
    app.component('reply-form', {
      emits: {
        // без валидации
        click: null,
    
        // с валидацией
        submit: payload => {
          if (payload.email && payload.password) {
            return true
          } else {
            console.warn('Некорректные данные для события submit!')
            return false
          }
        }
      }
    })
```
[[What is Vue]]
#vue
